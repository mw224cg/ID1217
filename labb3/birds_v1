#include <stdlib.h>
#include <stdio.h>
#include <pthread.h>
#include <semaphore.h>
#include <unistd.h>

#define W 10



sem_t empty; // 1 => tom skål => p får fylla på
sem_t full; // 1 => full skål => c får äta
sem_t mutex; //skyddar var 'worms' mellan c-trådarna

int worms = 15;
int num_babies = 5;

void* parent_function(void* arg){
    while(1){
        sem_wait(&empty); //kontrollera om skål är tom
        sem_wait(&mutex);

        worms = W;
        printf("Parent bird refilled bowl with %d worms\n", W);

        sem_post(&mutex);
        sem_post(&full); //signalera att skål är full => c får äta
    }
    return NULL;
}

void* baby_function(void* arg){
    int id = *(int*)arg; //deref + casta till int

    while(1){
        sem_wait(&full); //c får endast äta om skål har mat (startvärde 1 -> bäbis tar sem -> 0 stänger ute övriga)
        sem_wait(&mutex);

        worms--;
        printf("Baby bird %d ate 1 worm\n", id);

        if(worms == 0){
            printf("Bowl empty! Baby %d wakes parent\n", id);
            sem_post(&mutex);
            sem_post(&empty); // väck p
        } else {
            sem_post(&mutex);
            sem_post(&full); //sem(full) --> 1 nästa bebis får tillgång
        }
        sleep(1);
    }
    return NULL;


}

int main(int argc, char *argv[]){
    if(argc < 2){
        printf("Usage: %s + num of baby birds\n", argv[0]);
        printf("Number of baby birds: %d, Number of worms: %d\n", num_babies, W);
    } else {
        num_babies = atoi(argv[1]);
        printf("Number of baby birds: %d, Number of worms: %d\n", num_babies, W);
    }

    sem_init(&mutex, 0, 1);
    sem_init(&empty, 0, 0);
    sem_init(&full, 0, 1);

    pthread_t parent_thread;
    pthread_t baby_threads[num_babies];
    int ids[num_babies];

    pthread_create(&parent_thread, NULL, parent_function, NULL);
    for(int i = 0; i < num_babies; i++){
        ids[i] = i;
        pthread_create(&baby_threads[i], NULL, baby_function, &ids[i]);
    }

    pthread_join(parent_thread,NULL);
    for(int i = 0; i < num_babies; i++){
        pthread_join(baby_threads[i],NULL);
    }

    sem_destroy(&mutex);
    sem_destroy(&empty);
    sem_destroy(&full);
}
